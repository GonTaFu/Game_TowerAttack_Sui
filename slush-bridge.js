(function () {
    "use strict"; var C = function (e, t, n, a) { if (n === "a" && !a) throw new TypeError("Private accessor was defined without a getter"); if (typeof t == "function" ? e !== t || !a : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return n === "m" ? a : n === "a" ? a.call(e) : a ? a.value : t.get(e) }, O = function (e, t, n, a, o) { if (a === "m") throw new TypeError("Private method is not writable"); if (a === "a" && !o) throw new TypeError("Private accessor was defined without a setter"); if (typeof t == "function" ? e !== t || !o : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return a === "a" ? o.call(e, n) : o ? o.value = n : t.set(e, n), n }, h; let d; const g = new Set; function P(e) { f = void 0, g.add(e) } function _(e) { f = void 0, g.delete(e) } const i = {}; function v() {
        if (d || (d = Object.freeze({ register: y, get: N, on: F }), typeof window > "u")) return d; const e = Object.freeze({ register: y }); try { window.addEventListener("wallet-standard:register-wallet", ({ detail: t }) => t(e)) } catch (t) {
            console.error(`wallet-standard:register-wallet event listener could not be added
`, t)
        } try { window.dispatchEvent(new j(e)) } catch (t) {
            console.error(`wallet-standard:app-ready event could not be dispatched
`, t)
        } return d
    } function y(...e) { return e = e.filter(t => !g.has(t)), e.length ? (e.forEach(t => P(t)), i.register?.forEach(t => m(() => t(...e))), function () { e.forEach(n => _(n)), i.unregister?.forEach(n => m(() => n(...e))) }) : () => { } } let f; function N() { return f || (f = [...g]), f } function F(e, t) { return i[e]?.push(t) || (i[e] = [t]), function () { i[e] = i[e]?.filter(a => t !== a) } } function m(e) { try { e() } catch (t) { console.error(t) } } class j extends Event { get detail() { return C(this, h, "f") } get type() { return "wallet-standard:app-ready" } constructor(t) { super("wallet-standard:app-ready", { bubbles: !1, cancelable: !1, composed: !1 }), h.set(this, void 0), O(this, h, t, "f") } preventDefault() { throw new Error("preventDefault cannot be called") } stopImmediatePropagation() { throw new Error("stopImmediatePropagation cannot be called") } stopPropagation() { throw new Error("stopPropagation cannot be called") } } h = new WeakMap; const u = { chain: "sui:testnet", unityObjectName: "WalletBridge" }; function s(e) { return JSON.stringify(e, (t, n) => typeof n == "bigint" ? n.toString() : n instanceof Uint8Array ? Array.from(n) : n) } function l(e, t) { try { window.unityInstance?.SendMessage ? window.unityInstance.SendMessage(u.unityObjectName, e, t) : console.warn(`[SlushBridge] Unity not ready. ${e}:`, t) } catch (n) { console.error("[SlushBridge] unitySend failed:", n) } } function W(e) { return (e || "").trim().toLowerCase() } const w = v(); let c = w.get(); w.on("register", () => { c = w.get(), l("OnWalletRegistryChanged", s({ type: "register", wallets: c.map(e => e.name) })) }), w.on("unregister", () => { c = w.get(), l("OnWalletRegistryChanged", s({ type: "unregister", wallets: c.map(e => e.name) })) }); function R(e = "slush") { const t = W(e), n = c.find(o => W(o.name).includes(t)); return n || c.find(o => o.features && o.features["standard:connect"]) || null } function T(e, t) { const n = e?.features?.[t]; if (!n) throw new Error(`Wallet "${e?.name || "unknown"}" missing feature: ${t}`); return n } let r = { walletName: null, wallet: null, account: null, connected: !1 }; function b() { return !r.wallet || !r.account ? !1 : c.some(t => t === r.wallet || t.name === r.wallet.name) } async function E({ preferredWallet: e = "slush", silent: t = !1 } = {}) { try { if (r.connected && b()) return l("OnWalletConnected", s({ wallet: r.wallet.name, address: r.account.address, chain: u.chain, cached: !0 })), { wallet: r.wallet, account: r.account }; const n = R(e); if (!n) throw new Error("No Sui Wallet found (install/enable Slush or another Wallet Standard wallet)."); const S = (await T(n, "standard:connect").connect())?.accounts || []; if (!S.length) throw new Error("Wallet returned no accounts."); const p = S[0]; return r = { walletName: n.name, wallet: n, account: p, connected: !0 }, l("OnWalletConnected", s({ wallet: n.name, address: p.address, chain: u.chain, cached: !1 })), { wallet: n, account: p } } catch (n) { const a = String(n?.message || n); throw t || l("OnWalletError", a), n } } function A() { r = { walletName: null, wallet: null, account: null, connected: !1 }, l("OnWalletDisconnected", s({ ok: !0 })) } function I() { return !r.connected || !b() ? null : { wallet: r.wallet, account: r.account, walletName: r.wallet.name, address: r.account.address, chain: u.chain } } function B() { return c.map(e => ({ name: e.name, features: Object.keys(e.features || {}) })) } window.SlushBridge = { setConfig({ chain: e, unityObjectName: t } = {}) { e && (u.chain = e), t && (u.unityObjectName = t) }, listWallets() { const e = B(); return l("OnWalletsListed", s(e)), e }, async connect(e = "slush") { return await E({ preferredWallet: e, silent: !1 }) }, async tryReconnect(e = "slush") { try { return await E({ preferredWallet: e, silent: !0 }) } catch { return null } }, getConnection() { const e = I(); return l("OnConnectionInfo", s(e)), e }, disconnect() { A() } }
})();
